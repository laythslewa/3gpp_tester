/**
 * VAE_FileDistribution
 * API for VAE File Distribution Service Â© 2021, 3GPP Organizational Partners
 * (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0-alpha.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "FileList.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

FileList::FileList() {
  m_FileUri = "";
  m_FileDisplayUri = "";
  m_FileEarFetchTime = "";
  m_FileLatFetchTime = "";
  m_FileSize = 0;
  m_FileSizeIsSet = false;
  m_CompletionTime = "";
  m_KeepUpdateInterval = 0;
  m_UniAvailability = false;
  m_UniAvailabilityIsSet = false;
  m_FileRepetition = 0;
  m_FileRepetitionIsSet = false;
}

FileList::~FileList() {}

void FileList::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const FileList &o) {
  j = nlohmann::json();
  j["fileUri"] = o.m_FileUri;
  j["fileDisplayUri"] = o.m_FileDisplayUri;
  j["fileEarFetchTime"] = o.m_FileEarFetchTime;
  j["fileLatFetchTime"] = o.m_FileLatFetchTime;
  if (o.fileSizeIsSet())
    j["fileSize"] = o.m_FileSize;
  j["fileStatus"] = o.m_FileStatus;
  j["completionTime"] = o.m_CompletionTime;
  j["keepUpdateInterval"] = o.m_KeepUpdateInterval;
  if (o.uniAvailabilityIsSet())
    j["uniAvailability"] = o.m_UniAvailability;
  if (o.fileRepetitionIsSet())
    j["fileRepetition"] = o.m_FileRepetition;
}

void from_json(const nlohmann::json &j, FileList &o) {
  j.at("fileUri").get_to(o.m_FileUri);
  j.at("fileDisplayUri").get_to(o.m_FileDisplayUri);
  j.at("fileEarFetchTime").get_to(o.m_FileEarFetchTime);
  j.at("fileLatFetchTime").get_to(o.m_FileLatFetchTime);
  if (j.find("fileSize") != j.end()) {
    j.at("fileSize").get_to(o.m_FileSize);
    o.m_FileSizeIsSet = true;
  }
  j.at("fileStatus").get_to(o.m_FileStatus);
  j.at("completionTime").get_to(o.m_CompletionTime);
  j.at("keepUpdateInterval").get_to(o.m_KeepUpdateInterval);
  if (j.find("uniAvailability") != j.end()) {
    j.at("uniAvailability").get_to(o.m_UniAvailability);
    o.m_UniAvailabilityIsSet = true;
  }
  if (j.find("fileRepetition") != j.end()) {
    j.at("fileRepetition").get_to(o.m_FileRepetition);
    o.m_FileRepetitionIsSet = true;
  }
}

std::string FileList::getFileUri() const { return m_FileUri; }
void FileList::setFileUri(std::string const &value) { m_FileUri = value; }
std::string FileList::getFileDisplayUri() const { return m_FileDisplayUri; }
void FileList::setFileDisplayUri(std::string const &value) {
  m_FileDisplayUri = value;
}
std::string FileList::getFileEarFetchTime() const { return m_FileEarFetchTime; }
void FileList::setFileEarFetchTime(std::string const &value) {
  m_FileEarFetchTime = value;
}
std::string FileList::getFileLatFetchTime() const { return m_FileLatFetchTime; }
void FileList::setFileLatFetchTime(std::string const &value) {
  m_FileLatFetchTime = value;
}
int32_t FileList::getFileSize() const { return m_FileSize; }
void FileList::setFileSize(int32_t const value) {
  m_FileSize = value;
  m_FileSizeIsSet = true;
}
bool FileList::fileSizeIsSet() const { return m_FileSizeIsSet; }
void FileList::unsetFileSize() { m_FileSizeIsSet = false; }
FileStatus FileList::getFileStatus() const { return m_FileStatus; }
void FileList::setFileStatus(FileStatus const &value) { m_FileStatus = value; }
std::string FileList::getCompletionTime() const { return m_CompletionTime; }
void FileList::setCompletionTime(std::string const &value) {
  m_CompletionTime = value;
}
int32_t FileList::getKeepUpdateInterval() const { return m_KeepUpdateInterval; }
void FileList::setKeepUpdateInterval(int32_t const value) {
  m_KeepUpdateInterval = value;
}
bool FileList::isUniAvailability() const { return m_UniAvailability; }
void FileList::setUniAvailability(bool const value) {
  m_UniAvailability = value;
  m_UniAvailabilityIsSet = true;
}
bool FileList::uniAvailabilityIsSet() const { return m_UniAvailabilityIsSet; }
void FileList::unsetUniAvailability() { m_UniAvailabilityIsSet = false; }
int32_t FileList::getFileRepetition() const { return m_FileRepetition; }
void FileList::setFileRepetition(int32_t const value) {
  m_FileRepetition = value;
  m_FileRepetitionIsSet = true;
}
bool FileList::fileRepetitionIsSet() const { return m_FileRepetitionIsSet; }
void FileList::unsetFileRepetition() { m_FileRepetitionIsSet = false; }

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
