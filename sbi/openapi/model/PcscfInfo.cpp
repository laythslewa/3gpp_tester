/**
 * NRF NFManagement Service
 * NRF NFManagement Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "PcscfInfo.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

PcscfInfo::PcscfInfo() {
  m_AccessTypeIsSet = false;
  m_DnnListIsSet = false;
  m_GmFqdn = "";
  m_GmFqdnIsSet = false;
  m_GmIpv4AddressesIsSet = false;
  m_GmIpv6AddressesIsSet = false;
  m_ServedIpv4AddressRangesIsSet = false;
  m_ServedIpv6PrefixRangesIsSet = false;
}

PcscfInfo::~PcscfInfo() {}

void PcscfInfo::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const PcscfInfo &o) {
  j = nlohmann::json();
  if (o.accessTypeIsSet() || !o.m_AccessType.empty())
    j["accessType"] = o.m_AccessType;
  if (o.dnnListIsSet() || !o.m_DnnList.empty())
    j["dnnList"] = o.m_DnnList;
  if (o.gmFqdnIsSet())
    j["gmFqdn"] = o.m_GmFqdn;
  if (o.gmIpv4AddressesIsSet() || !o.m_GmIpv4Addresses.empty())
    j["gmIpv4Addresses"] = o.m_GmIpv4Addresses;
  if (o.gmIpv6AddressesIsSet() || !o.m_GmIpv6Addresses.empty())
    j["gmIpv6Addresses"] = o.m_GmIpv6Addresses;
  if (o.servedIpv4AddressRangesIsSet() || !o.m_ServedIpv4AddressRanges.empty())
    j["servedIpv4AddressRanges"] = o.m_ServedIpv4AddressRanges;
  if (o.servedIpv6PrefixRangesIsSet() || !o.m_ServedIpv6PrefixRanges.empty())
    j["servedIpv6PrefixRanges"] = o.m_ServedIpv6PrefixRanges;
}

void from_json(const nlohmann::json &j, PcscfInfo &o) {
  if (j.find("accessType") != j.end()) {
    j.at("accessType").get_to(o.m_AccessType);
    o.m_AccessTypeIsSet = true;
  }
  if (j.find("dnnList") != j.end()) {
    j.at("dnnList").get_to(o.m_DnnList);
    o.m_DnnListIsSet = true;
  }
  if (j.find("gmFqdn") != j.end()) {
    j.at("gmFqdn").get_to(o.m_GmFqdn);
    o.m_GmFqdnIsSet = true;
  }
  if (j.find("gmIpv4Addresses") != j.end()) {
    j.at("gmIpv4Addresses").get_to(o.m_GmIpv4Addresses);
    o.m_GmIpv4AddressesIsSet = true;
  }
  if (j.find("gmIpv6Addresses") != j.end()) {
    j.at("gmIpv6Addresses").get_to(o.m_GmIpv6Addresses);
    o.m_GmIpv6AddressesIsSet = true;
  }
  if (j.find("servedIpv4AddressRanges") != j.end()) {
    j.at("servedIpv4AddressRanges").get_to(o.m_ServedIpv4AddressRanges);
    o.m_ServedIpv4AddressRangesIsSet = true;
  }
  if (j.find("servedIpv6PrefixRanges") != j.end()) {
    j.at("servedIpv6PrefixRanges").get_to(o.m_ServedIpv6PrefixRanges);
    o.m_ServedIpv6PrefixRangesIsSet = true;
  }
}

std::vector<AccessType> &PcscfInfo::getAccessType() { return m_AccessType; }
void PcscfInfo::setAccessType(std::vector<AccessType> const &value) {
  m_AccessType = value;
  m_AccessTypeIsSet = true;
}
bool PcscfInfo::accessTypeIsSet() const { return m_AccessTypeIsSet; }
void PcscfInfo::unsetAccessType() { m_AccessTypeIsSet = false; }
std::vector<std::string> &PcscfInfo::getDnnList() { return m_DnnList; }
void PcscfInfo::setDnnList(std::vector<std::string> const &value) {
  m_DnnList = value;
  m_DnnListIsSet = true;
}
bool PcscfInfo::dnnListIsSet() const { return m_DnnListIsSet; }
void PcscfInfo::unsetDnnList() { m_DnnListIsSet = false; }
std::string PcscfInfo::getGmFqdn() const { return m_GmFqdn; }
void PcscfInfo::setGmFqdn(std::string const &value) {
  m_GmFqdn = value;
  m_GmFqdnIsSet = true;
}
bool PcscfInfo::gmFqdnIsSet() const { return m_GmFqdnIsSet; }
void PcscfInfo::unsetGmFqdn() { m_GmFqdnIsSet = false; }
std::vector<std::string> &PcscfInfo::getGmIpv4Addresses() {
  return m_GmIpv4Addresses;
}
void PcscfInfo::setGmIpv4Addresses(std::vector<std::string> const &value) {
  m_GmIpv4Addresses = value;
  m_GmIpv4AddressesIsSet = true;
}
bool PcscfInfo::gmIpv4AddressesIsSet() const { return m_GmIpv4AddressesIsSet; }
void PcscfInfo::unsetGmIpv4Addresses() { m_GmIpv4AddressesIsSet = false; }
std::vector<Ipv6Addr> &PcscfInfo::getGmIpv6Addresses() {
  return m_GmIpv6Addresses;
}
void PcscfInfo::setGmIpv6Addresses(std::vector<Ipv6Addr> const &value) {
  m_GmIpv6Addresses = value;
  m_GmIpv6AddressesIsSet = true;
}
bool PcscfInfo::gmIpv6AddressesIsSet() const { return m_GmIpv6AddressesIsSet; }
void PcscfInfo::unsetGmIpv6Addresses() { m_GmIpv6AddressesIsSet = false; }
std::vector<Ipv4AddressRange> &PcscfInfo::getServedIpv4AddressRanges() {
  return m_ServedIpv4AddressRanges;
}
void PcscfInfo::setServedIpv4AddressRanges(
    std::vector<Ipv4AddressRange> const &value) {
  m_ServedIpv4AddressRanges = value;
  m_ServedIpv4AddressRangesIsSet = true;
}
bool PcscfInfo::servedIpv4AddressRangesIsSet() const {
  return m_ServedIpv4AddressRangesIsSet;
}
void PcscfInfo::unsetServedIpv4AddressRanges() {
  m_ServedIpv4AddressRangesIsSet = false;
}
std::vector<Ipv6PrefixRange> &PcscfInfo::getServedIpv6PrefixRanges() {
  return m_ServedIpv6PrefixRanges;
}
void PcscfInfo::setServedIpv6PrefixRanges(
    std::vector<Ipv6PrefixRange> const &value) {
  m_ServedIpv6PrefixRanges = value;
  m_ServedIpv6PrefixRangesIsSet = true;
}
bool PcscfInfo::servedIpv6PrefixRangesIsSet() const {
  return m_ServedIpv6PrefixRangesIsSet;
}
void PcscfInfo::unsetServedIpv6PrefixRanges() {
  m_ServedIpv6PrefixRangesIsSet = false;
}

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
