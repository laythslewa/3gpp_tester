/**
 * M1_ContentProtocolsDiscovery
 * 5GMS AF M1 Content Protocols Discovery API Â© 2021, 3GPP Organizational
 * Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "ContentProtocols.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

ContentProtocols::ContentProtocols() {
  m_DownlinkIngestProtocolsIsSet = false;
  m_UplinkEgestProtocolsIsSet = false;
  m_GeoFencingLocatorTypesIsSet = false;
}

ContentProtocols::~ContentProtocols() {}

void ContentProtocols::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const ContentProtocols &o) {
  j = nlohmann::json();
  if (o.downlinkIngestProtocolsIsSet() || !o.m_DownlinkIngestProtocols.empty())
    j["downlinkIngestProtocols"] = o.m_DownlinkIngestProtocols;
  if (o.uplinkEgestProtocolsIsSet() || !o.m_UplinkEgestProtocols.empty())
    j["uplinkEgestProtocols"] = o.m_UplinkEgestProtocols;
  if (o.geoFencingLocatorTypesIsSet() || !o.m_GeoFencingLocatorTypes.empty())
    j["geoFencingLocatorTypes"] = o.m_GeoFencingLocatorTypes;
}

void from_json(const nlohmann::json &j, ContentProtocols &o) {
  if (j.find("downlinkIngestProtocols") != j.end()) {
    j.at("downlinkIngestProtocols").get_to(o.m_DownlinkIngestProtocols);
    o.m_DownlinkIngestProtocolsIsSet = true;
  }
  if (j.find("uplinkEgestProtocols") != j.end()) {
    j.at("uplinkEgestProtocols").get_to(o.m_UplinkEgestProtocols);
    o.m_UplinkEgestProtocolsIsSet = true;
  }
  if (j.find("geoFencingLocatorTypes") != j.end()) {
    j.at("geoFencingLocatorTypes").get_to(o.m_GeoFencingLocatorTypes);
    o.m_GeoFencingLocatorTypesIsSet = true;
  }
}

std::vector<ContentProtocolDescriptor> &
ContentProtocols::getDownlinkIngestProtocols() {
  return m_DownlinkIngestProtocols;
}
void ContentProtocols::setDownlinkIngestProtocols(
    std::vector<ContentProtocolDescriptor> const &value) {
  m_DownlinkIngestProtocols = value;
  m_DownlinkIngestProtocolsIsSet = true;
}
bool ContentProtocols::downlinkIngestProtocolsIsSet() const {
  return m_DownlinkIngestProtocolsIsSet;
}
void ContentProtocols::unsetDownlinkIngestProtocols() {
  m_DownlinkIngestProtocolsIsSet = false;
}
std::vector<ContentProtocolDescriptor> &
ContentProtocols::getUplinkEgestProtocols() {
  return m_UplinkEgestProtocols;
}
void ContentProtocols::setUplinkEgestProtocols(
    std::vector<ContentProtocolDescriptor> const &value) {
  m_UplinkEgestProtocols = value;
  m_UplinkEgestProtocolsIsSet = true;
}
bool ContentProtocols::uplinkEgestProtocolsIsSet() const {
  return m_UplinkEgestProtocolsIsSet;
}
void ContentProtocols::unsetUplinkEgestProtocols() {
  m_UplinkEgestProtocolsIsSet = false;
}
std::vector<std::string> &ContentProtocols::getGeoFencingLocatorTypes() {
  return m_GeoFencingLocatorTypes;
}
void ContentProtocols::setGeoFencingLocatorTypes(
    std::vector<std::string> const &value) {
  m_GeoFencingLocatorTypes = value;
  m_GeoFencingLocatorTypesIsSet = true;
}
bool ContentProtocols::geoFencingLocatorTypesIsSet() const {
  return m_GeoFencingLocatorTypesIsSet;
}
void ContentProtocols::unsetGeoFencingLocatorTypes() {
  m_GeoFencingLocatorTypesIsSet = false;
}

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
