/**
 * Ngmlc_Location
 * Ngmlc_Location Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0-alpha.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "AreaEventInfoExt.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

AreaEventInfoExt::AreaEventInfoExt() {
  m_OccurrenceInfoIsSet = false;
  m_MinimumInterval = 0;
  m_MinimumIntervalIsSet = false;
  m_MaximumInterval = 0;
  m_MaximumIntervalIsSet = false;
  m_SamplingInterval = 0;
  m_SamplingIntervalIsSet = false;
  m_ReportingDuration = 0;
  m_ReportingDurationIsSet = false;
  m_ReportingLocationReq = false;
  m_ReportingLocationReqIsSet = false;
  m_GeoAreaListIsSet = false;
  m_IgnoreAreaDefInd = false;
  m_IgnoreAreaDefIndIsSet = false;
}

AreaEventInfoExt::~AreaEventInfoExt() {}

void AreaEventInfoExt::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const AreaEventInfoExt &o) {
  j = nlohmann::json();
  j["areaDefinition"] = o.m_AreaDefinition;
  if (o.occurrenceInfoIsSet())
    j["occurrenceInfo"] = o.m_OccurrenceInfo;
  if (o.minimumIntervalIsSet())
    j["minimumInterval"] = o.m_MinimumInterval;
  if (o.maximumIntervalIsSet())
    j["maximumInterval"] = o.m_MaximumInterval;
  if (o.samplingIntervalIsSet())
    j["samplingInterval"] = o.m_SamplingInterval;
  if (o.reportingDurationIsSet())
    j["reportingDuration"] = o.m_ReportingDuration;
  if (o.reportingLocationReqIsSet())
    j["reportingLocationReq"] = o.m_ReportingLocationReq;
  if (o.geoAreaListIsSet() || !o.m_GeoAreaList.empty())
    j["geoAreaList"] = o.m_GeoAreaList;
  if (o.ignoreAreaDefIndIsSet())
    j["ignoreAreaDefInd"] = o.m_IgnoreAreaDefInd;
}

void from_json(const nlohmann::json &j, AreaEventInfoExt &o) {
  j.at("areaDefinition").get_to(o.m_AreaDefinition);
  if (j.find("occurrenceInfo") != j.end()) {
    j.at("occurrenceInfo").get_to(o.m_OccurrenceInfo);
    o.m_OccurrenceInfoIsSet = true;
  }
  if (j.find("minimumInterval") != j.end()) {
    j.at("minimumInterval").get_to(o.m_MinimumInterval);
    o.m_MinimumIntervalIsSet = true;
  }
  if (j.find("maximumInterval") != j.end()) {
    j.at("maximumInterval").get_to(o.m_MaximumInterval);
    o.m_MaximumIntervalIsSet = true;
  }
  if (j.find("samplingInterval") != j.end()) {
    j.at("samplingInterval").get_to(o.m_SamplingInterval);
    o.m_SamplingIntervalIsSet = true;
  }
  if (j.find("reportingDuration") != j.end()) {
    j.at("reportingDuration").get_to(o.m_ReportingDuration);
    o.m_ReportingDurationIsSet = true;
  }
  if (j.find("reportingLocationReq") != j.end()) {
    j.at("reportingLocationReq").get_to(o.m_ReportingLocationReq);
    o.m_ReportingLocationReqIsSet = true;
  }
  if (j.find("geoAreaList") != j.end()) {
    j.at("geoAreaList").get_to(o.m_GeoAreaList);
    o.m_GeoAreaListIsSet = true;
  }
  if (j.find("ignoreAreaDefInd") != j.end()) {
    j.at("ignoreAreaDefInd").get_to(o.m_IgnoreAreaDefInd);
    o.m_IgnoreAreaDefIndIsSet = true;
  }
}

std::vector<ReportingArea> &AreaEventInfoExt::getAreaDefinition() {
  return m_AreaDefinition;
}
void AreaEventInfoExt::setAreaDefinition(
    std::vector<ReportingArea> const &value) {
  m_AreaDefinition = value;
}
OccurrenceInfo AreaEventInfoExt::getOccurrenceInfo() const {
  return m_OccurrenceInfo;
}
void AreaEventInfoExt::setOccurrenceInfo(OccurrenceInfo const &value) {
  m_OccurrenceInfo = value;
  m_OccurrenceInfoIsSet = true;
}
bool AreaEventInfoExt::occurrenceInfoIsSet() const {
  return m_OccurrenceInfoIsSet;
}
void AreaEventInfoExt::unsetOccurrenceInfo() { m_OccurrenceInfoIsSet = false; }
int32_t AreaEventInfoExt::getMinimumInterval() const {
  return m_MinimumInterval;
}
void AreaEventInfoExt::setMinimumInterval(int32_t const value) {
  m_MinimumInterval = value;
  m_MinimumIntervalIsSet = true;
}
bool AreaEventInfoExt::minimumIntervalIsSet() const {
  return m_MinimumIntervalIsSet;
}
void AreaEventInfoExt::unsetMinimumInterval() {
  m_MinimumIntervalIsSet = false;
}
int32_t AreaEventInfoExt::getMaximumInterval() const {
  return m_MaximumInterval;
}
void AreaEventInfoExt::setMaximumInterval(int32_t const value) {
  m_MaximumInterval = value;
  m_MaximumIntervalIsSet = true;
}
bool AreaEventInfoExt::maximumIntervalIsSet() const {
  return m_MaximumIntervalIsSet;
}
void AreaEventInfoExt::unsetMaximumInterval() {
  m_MaximumIntervalIsSet = false;
}
int32_t AreaEventInfoExt::getSamplingInterval() const {
  return m_SamplingInterval;
}
void AreaEventInfoExt::setSamplingInterval(int32_t const value) {
  m_SamplingInterval = value;
  m_SamplingIntervalIsSet = true;
}
bool AreaEventInfoExt::samplingIntervalIsSet() const {
  return m_SamplingIntervalIsSet;
}
void AreaEventInfoExt::unsetSamplingInterval() {
  m_SamplingIntervalIsSet = false;
}
int32_t AreaEventInfoExt::getReportingDuration() const {
  return m_ReportingDuration;
}
void AreaEventInfoExt::setReportingDuration(int32_t const value) {
  m_ReportingDuration = value;
  m_ReportingDurationIsSet = true;
}
bool AreaEventInfoExt::reportingDurationIsSet() const {
  return m_ReportingDurationIsSet;
}
void AreaEventInfoExt::unsetReportingDuration() {
  m_ReportingDurationIsSet = false;
}
bool AreaEventInfoExt::isReportingLocationReq() const {
  return m_ReportingLocationReq;
}
void AreaEventInfoExt::setReportingLocationReq(bool const value) {
  m_ReportingLocationReq = value;
  m_ReportingLocationReqIsSet = true;
}
bool AreaEventInfoExt::reportingLocationReqIsSet() const {
  return m_ReportingLocationReqIsSet;
}
void AreaEventInfoExt::unsetReportingLocationReq() {
  m_ReportingLocationReqIsSet = false;
}
std::vector<GeographicArea> &AreaEventInfoExt::getGeoAreaList() {
  return m_GeoAreaList;
}
void AreaEventInfoExt::setGeoAreaList(
    std::vector<GeographicArea> const &value) {
  m_GeoAreaList = value;
  m_GeoAreaListIsSet = true;
}
bool AreaEventInfoExt::geoAreaListIsSet() const { return m_GeoAreaListIsSet; }
void AreaEventInfoExt::unsetGeoAreaList() { m_GeoAreaListIsSet = false; }
bool AreaEventInfoExt::isIgnoreAreaDefInd() const { return m_IgnoreAreaDefInd; }
void AreaEventInfoExt::setIgnoreAreaDefInd(bool const value) {
  m_IgnoreAreaDefInd = value;
  m_IgnoreAreaDefIndIsSet = true;
}
bool AreaEventInfoExt::ignoreAreaDefIndIsSet() const {
  return m_IgnoreAreaDefIndIsSet;
}
void AreaEventInfoExt::unsetIgnoreAreaDefInd() {
  m_IgnoreAreaDefIndIsSet = false;
}

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
