/**
 * Npcf_SMPolicyControl API
 * Session Management Policy Control Service © 2021, 3GPP Organizational
 * Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */
/*
 * SmPolicyDecision.h
 *
 * Contains the SM policies authorized by the PCF.
 */

#ifndef SmPolicyDecision_H_
#define SmPolicyDecision_H_

#include "BridgeManagementContainer.h"
#include "ChargingData.h"
#include "ChargingInformation.h"
#include "ConditionData.h"
#include "PccRule.h"
#include "PolicyControlRequestTrigger.h"
#include "PortManagementContainer.h"
#include "PresenceInfoRm.h"
#include "QosCharacteristics.h"
#include "QosData.h"
#include "QosFlowUsage.h"
#include "QosMonitoringData.h"
#include "RequestedRuleData.h"
#include "RequestedUsageData.h"
#include "SessionRule.h"
#include "SmPolicyAssociationReleaseCause.h"
#include "TrafficControlData.h"
#include "UsageMonitoringData.h"
#include <map>
#include <nlohmann/json.hpp>
#include <string>
#include <vector>

namespace org {
namespace openapitools {
namespace server {
namespace model {

/// <summary>
/// Contains the SM policies authorized by the PCF.
/// </summary>
class SmPolicyDecision {
public:
  SmPolicyDecision();
  virtual ~SmPolicyDecision();

  void validate();

  /////////////////////////////////////////////
  /// SmPolicyDecision members

  /// <summary>
  /// A map of Sessionrules with the content being the SessionRule as described
  /// in subclause 5.6.2.7. The key used in this map for each entry is the
  /// sessRuleId attribute of the corresponding SessionRule.
  /// </summary>
  std::map<std::string, SessionRule> &getSessRules();
  void setSessRules(std::map<std::string, SessionRule> const &value);
  bool sessRulesIsSet() const;
  void unsetSessRules();
  /// <summary>
  /// A map of PCC rules with the content being the PCCRule as described in
  /// subclause 5.6.2.6. The key used in this map for each entry is the
  /// pccRuleId attribute of the corresponding PccRule.
  /// </summary>
  std::map<std::string, PccRule> &getPccRules();
  void setPccRules(std::map<std::string, PccRule> const &value);
  bool pccRulesIsSet() const;
  void unsetPccRules();
  /// <summary>
  /// If it is included and set to true, it indicates the P-CSCF Restoration is
  /// requested.
  /// </summary>
  bool isPcscfRestIndication() const;
  void setPcscfRestIndication(bool const value);
  bool pcscfRestIndicationIsSet() const;
  void unsetPcscfRestIndication();
  /// <summary>
  /// Map of QoS data policy decisions. The key used in this map for each entry
  /// is the qosId attribute of the corresponding QosData.
  /// </summary>
  std::map<std::string, QosData> &getQosDecs();
  void setQosDecs(std::map<std::string, QosData> const &value);
  bool qosDecsIsSet() const;
  void unsetQosDecs();
  /// <summary>
  /// Map of Charging data policy decisions. The key used in this map for each
  /// entry is the chgId attribute of the corresponding ChargingData.
  /// </summary>
  std::map<std::string, ChargingData> &getChgDecs();
  void setChgDecs(std::map<std::string, ChargingData> const &value);
  bool chgDecsIsSet() const;
  void unsetChgDecs();
  /// <summary>
  ///
  /// </summary>
  ChargingInformation getChargingInfo() const;
  void setChargingInfo(ChargingInformation const &value);
  bool chargingInfoIsSet() const;
  void unsetChargingInfo();
  /// <summary>
  /// Map of Traffic Control data policy decisions. The key used in this map for
  /// each entry is the tcId attribute of the corresponding TrafficControlData.
  /// </summary>
  std::map<std::string, TrafficControlData> &getTraffContDecs();
  void setTraffContDecs(std::map<std::string, TrafficControlData> const &value);
  bool traffContDecsIsSet() const;
  void unsetTraffContDecs();
  /// <summary>
  /// Map of Usage Monitoring data policy decisions. The key used in this map
  /// for each entry is the umId attribute of the corresponding
  /// UsageMonitoringData.
  /// </summary>
  std::map<std::string, UsageMonitoringData> &getUmDecs();
  void setUmDecs(std::map<std::string, UsageMonitoringData> const &value);
  bool umDecsIsSet() const;
  void unsetUmDecs();
  /// <summary>
  /// Map of QoS characteristics for non standard 5QIs. This map uses the 5QI
  /// values as keys.
  /// </summary>
  std::map<std::string, QosCharacteristics> &getQosChars();
  void setQosChars(std::map<std::string, QosCharacteristics> const &value);
  bool qosCharsIsSet() const;
  void unsetQosChars();
  /// <summary>
  /// Map of QoS Monitoring data policy decisions. The key used in this map for
  /// each entry is the qmId attribute of the corresponding QosMonitoringData.
  /// </summary>
  std::map<std::string, QosMonitoringData> &getQosMonDecs();
  void setQosMonDecs(std::map<std::string, QosMonitoringData> const &value);
  bool qosMonDecsIsSet() const;
  void unsetQosMonDecs();
  /// <summary>
  /// indicating a time in seconds.
  /// </summary>
  int32_t getReflectiveQoSTimer() const;
  void setReflectiveQoSTimer(int32_t const value);
  bool reflectiveQoSTimerIsSet() const;
  void unsetReflectiveQoSTimer();
  /// <summary>
  /// A map of condition data with the content being as described in
  /// subclause 5.6.2.9. The key used in this map for each entry is the condId
  /// attribute of the corresponding ConditionData.
  /// </summary>
  std::map<std::string, ConditionData> &getConds();
  void setConds(std::map<std::string, ConditionData> const &value);
  bool condsIsSet() const;
  void unsetConds();
  /// <summary>
  /// string with format \&quot;date-time\&quot; as defined in OpenAPI.
  /// </summary>
  std::string getRevalidationTime() const;
  void setRevalidationTime(std::string const &value);
  bool revalidationTimeIsSet() const;
  void unsetRevalidationTime();
  /// <summary>
  /// Indicates the offline charging is applicable to the PDU session when it is
  /// included and set to true.
  /// </summary>
  bool isOffline() const;
  void setOffline(bool const value);
  bool offlineIsSet() const;
  void unsetOffline();
  /// <summary>
  /// Indicates the online charging is applicable to the PDU session when it is
  /// included and set to true.
  /// </summary>
  bool isOnline() const;
  void setOnline(bool const value);
  bool onlineIsSet() const;
  void unsetOnline();
  /// <summary>
  /// Indicates that the online charging method shall never be used for any PCC
  /// rule activated during the lifetime of the PDU session.
  /// </summary>
  bool isOfflineChOnly() const;
  void setOfflineChOnly(bool const value);
  bool offlineChOnlyIsSet() const;
  void unsetOfflineChOnly();
  /// <summary>
  /// Defines the policy control request triggers subscribed by the PCF.
  /// </summary>
  std::vector<PolicyControlRequestTrigger> &getPolicyCtrlReqTriggers();
  void setPolicyCtrlReqTriggers(
      std::vector<PolicyControlRequestTrigger> const &value);
  bool policyCtrlReqTriggersIsSet() const;
  void unsetPolicyCtrlReqTriggers();
  /// <summary>
  /// Defines the last list of rule control data requested by the PCF.
  /// </summary>
  std::vector<RequestedRuleData> &getLastReqRuleData();
  void setLastReqRuleData(std::vector<RequestedRuleData> const &value);
  bool lastReqRuleDataIsSet() const;
  void unsetLastReqRuleData();
  /// <summary>
  ///
  /// </summary>
  RequestedUsageData getLastReqUsageData() const;
  void setLastReqUsageData(RequestedUsageData const &value);
  bool lastReqUsageDataIsSet() const;
  void unsetLastReqUsageData();
  /// <summary>
  /// Map of PRA information. The praId attribute within the PresenceInfo data
  /// type is the key of the map.
  /// </summary>
  std::map<std::string, PresenceInfoRm> &getPraInfos();
  void setPraInfos(std::map<std::string, PresenceInfoRm> const &value);
  bool praInfosIsSet() const;
  void unsetPraInfos();
  /// <summary>
  /// Represents information that identifies which IP pool or external server is
  /// used to allocate the IP address.
  /// </summary>
  int32_t getIpv4Index() const;
  void setIpv4Index(int32_t const value);
  bool ipv4IndexIsSet() const;
  void unsetIpv4Index();
  /// <summary>
  /// Represents information that identifies which IP pool or external server is
  /// used to allocate the IP address.
  /// </summary>
  int32_t getIpv6Index() const;
  void setIpv6Index(int32_t const value);
  bool ipv6IndexIsSet() const;
  void unsetIpv6Index();
  /// <summary>
  ///
  /// </summary>
  QosFlowUsage getQosFlowUsage() const;
  void setQosFlowUsage(QosFlowUsage const &value);
  bool qosFlowUsageIsSet() const;
  void unsetQosFlowUsage();
  /// <summary>
  ///
  /// </summary>
  SmPolicyAssociationReleaseCause getRelCause() const;
  void setRelCause(SmPolicyAssociationReleaseCause const &value);
  bool relCauseIsSet() const;
  void unsetRelCause();
  /// <summary>
  /// A string used to indicate the features supported by an API that is used as
  /// defined in clause 6.6 in 3GPP TS 29.500. The string shall contain a
  /// bitmask indicating supported features in hexadecimal representation Each
  /// character in the string shall take a value of \&quot;0\&quot; to
  /// \&quot;9\&quot;, \&quot;a\&quot; to \&quot;f\&quot; or \&quot;A\&quot; to
  /// \&quot;F\&quot; and shall represent the support of 4 features as described
  /// in table 5.2.2-3. The most significant character representing the
  /// highest-numbered features shall appear first in the string, and the
  /// character representing features 1 to 4 shall appear last in the string.
  /// The list of features and their numbering (starting with 1) are defined
  /// separately for each API. If the string contains a lower number of
  /// characters than there are defined features for an API, all features that
  /// would be represented by characters that are not present in the string are
  /// not supported
  /// </summary>
  std::string getSuppFeat() const;
  void setSuppFeat(std::string const &value);
  bool suppFeatIsSet() const;
  void unsetSuppFeat();
  /// <summary>
  ///
  /// </summary>
  BridgeManagementContainer getTsnBridgeManCont() const;
  void setTsnBridgeManCont(BridgeManagementContainer const &value);
  bool tsnBridgeManContIsSet() const;
  void unsetTsnBridgeManCont();
  /// <summary>
  ///
  /// </summary>
  PortManagementContainer getTsnPortManContDstt() const;
  void setTsnPortManContDstt(PortManagementContainer const &value);
  bool tsnPortManContDsttIsSet() const;
  void unsetTsnPortManContDstt();
  /// <summary>
  ///
  /// </summary>
  std::vector<PortManagementContainer> &getTsnPortManContNwtts();
  void
  setTsnPortManContNwtts(std::vector<PortManagementContainer> const &value);
  bool tsnPortManContNwttsIsSet() const;
  void unsetTsnPortManContNwtts();
  /// <summary>
  /// Indicates whether the PDU session is a redundant PDU session. If absent it
  /// means the PDU session is not a redundant PDU session.
  /// </summary>
  bool isRedSessIndication() const;
  void setRedSessIndication(bool const value);
  bool redSessIndicationIsSet() const;
  void unsetRedSessIndication();

  friend void to_json(nlohmann::json &j, const SmPolicyDecision &o);
  friend void from_json(const nlohmann::json &j, SmPolicyDecision &o);

protected:
  std::map<std::string, SessionRule> m_SessRules;
  bool m_SessRulesIsSet;
  std::map<std::string, PccRule> m_PccRules;
  bool m_PccRulesIsSet;
  bool m_PcscfRestIndication;
  bool m_PcscfRestIndicationIsSet;
  std::map<std::string, QosData> m_QosDecs;
  bool m_QosDecsIsSet;
  std::map<std::string, ChargingData> m_ChgDecs;
  bool m_ChgDecsIsSet;
  ChargingInformation m_ChargingInfo;
  bool m_ChargingInfoIsSet;
  std::map<std::string, TrafficControlData> m_TraffContDecs;
  bool m_TraffContDecsIsSet;
  std::map<std::string, UsageMonitoringData> m_UmDecs;
  bool m_UmDecsIsSet;
  std::map<std::string, QosCharacteristics> m_QosChars;
  bool m_QosCharsIsSet;
  std::map<std::string, QosMonitoringData> m_QosMonDecs;
  bool m_QosMonDecsIsSet;
  int32_t m_ReflectiveQoSTimer;
  bool m_ReflectiveQoSTimerIsSet;
  std::map<std::string, ConditionData> m_Conds;
  bool m_CondsIsSet;
  std::string m_RevalidationTime;
  bool m_RevalidationTimeIsSet;
  bool m_Offline;
  bool m_OfflineIsSet;
  bool m_Online;
  bool m_OnlineIsSet;
  bool m_OfflineChOnly;
  bool m_OfflineChOnlyIsSet;
  std::vector<PolicyControlRequestTrigger> m_PolicyCtrlReqTriggers;
  bool m_PolicyCtrlReqTriggersIsSet;
  std::vector<RequestedRuleData> m_LastReqRuleData;
  bool m_LastReqRuleDataIsSet;
  RequestedUsageData m_LastReqUsageData;
  bool m_LastReqUsageDataIsSet;
  std::map<std::string, PresenceInfoRm> m_PraInfos;
  bool m_PraInfosIsSet;
  int32_t m_Ipv4Index;
  bool m_Ipv4IndexIsSet;
  int32_t m_Ipv6Index;
  bool m_Ipv6IndexIsSet;
  QosFlowUsage m_QosFlowUsage;
  bool m_QosFlowUsageIsSet;
  SmPolicyAssociationReleaseCause m_RelCause;
  bool m_RelCauseIsSet;
  std::string m_SuppFeat;
  bool m_SuppFeatIsSet;
  BridgeManagementContainer m_TsnBridgeManCont;
  bool m_TsnBridgeManContIsSet;
  PortManagementContainer m_TsnPortManContDstt;
  bool m_TsnPortManContDsttIsSet;
  std::vector<PortManagementContainer> m_TsnPortManContNwtts;
  bool m_TsnPortManContNwttsIsSet;
  bool m_RedSessIndication;
  bool m_RedSessIndicationIsSet;
};

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org

#endif /* SmPolicyDecision_H_ */
