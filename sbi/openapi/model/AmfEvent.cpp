/**
 * Namf_EventExposure
 * AMF Event Exposure Service Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "AmfEvent.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

AmfEvent::AmfEvent() {
  m_ImmediateFlag = false;
  m_ImmediateFlagIsSet = false;
  m_AreaListIsSet = false;
  m_LocationFilterListIsSet = false;
  m_RefId = 0;
  m_RefIdIsSet = false;
  m_TrafficDescriptorListIsSet = false;
  m_ReportUeReachable = false;
  m_ReportUeReachableIsSet = false;
  m_ReachabilityFilterIsSet = false;
  m_UdmDetectInd = false;
  m_UdmDetectIndIsSet = false;
  m_MaxReports = 0;
  m_MaxReportsIsSet = false;
  m_PresenceInfoListIsSet = false;
  m_MaxResponseTime = 0;
  m_MaxResponseTimeIsSet = false;
  m_TargetAreaIsSet = false;
  m_SnssaiFilterIsSet = false;
}

AmfEvent::~AmfEvent() {}

void AmfEvent::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const AmfEvent &o) {
  j = nlohmann::json();
  j["type"] = o.m_Type;
  if (o.immediateFlagIsSet())
    j["immediateFlag"] = o.m_ImmediateFlag;
  if (o.areaListIsSet() || !o.m_AreaList.empty())
    j["areaList"] = o.m_AreaList;
  if (o.locationFilterListIsSet() || !o.m_LocationFilterList.empty())
    j["locationFilterList"] = o.m_LocationFilterList;
  if (o.refIdIsSet())
    j["refId"] = o.m_RefId;
  if (o.trafficDescriptorListIsSet() || !o.m_TrafficDescriptorList.empty())
    j["trafficDescriptorList"] = o.m_TrafficDescriptorList;
  if (o.reportUeReachableIsSet())
    j["reportUeReachable"] = o.m_ReportUeReachable;
  if (o.reachabilityFilterIsSet())
    j["reachabilityFilter"] = o.m_ReachabilityFilter;
  if (o.udmDetectIndIsSet())
    j["udmDetectInd"] = o.m_UdmDetectInd;
  if (o.maxReportsIsSet())
    j["maxReports"] = o.m_MaxReports;
  if (o.presenceInfoListIsSet() || !o.m_PresenceInfoList.empty())
    j["presenceInfoList"] = o.m_PresenceInfoList;
  if (o.maxResponseTimeIsSet())
    j["maxResponseTime"] = o.m_MaxResponseTime;
  if (o.targetAreaIsSet())
    j["targetArea"] = o.m_TargetArea;
  if (o.snssaiFilterIsSet() || !o.m_SnssaiFilter.empty())
    j["snssaiFilter"] = o.m_SnssaiFilter;
}

void from_json(const nlohmann::json &j, AmfEvent &o) {
  j.at("type").get_to(o.m_Type);
  if (j.find("immediateFlag") != j.end()) {
    j.at("immediateFlag").get_to(o.m_ImmediateFlag);
    o.m_ImmediateFlagIsSet = true;
  }
  if (j.find("areaList") != j.end()) {
    j.at("areaList").get_to(o.m_AreaList);
    o.m_AreaListIsSet = true;
  }
  if (j.find("locationFilterList") != j.end()) {
    j.at("locationFilterList").get_to(o.m_LocationFilterList);
    o.m_LocationFilterListIsSet = true;
  }
  if (j.find("refId") != j.end()) {
    j.at("refId").get_to(o.m_RefId);
    o.m_RefIdIsSet = true;
  }
  if (j.find("trafficDescriptorList") != j.end()) {
    j.at("trafficDescriptorList").get_to(o.m_TrafficDescriptorList);
    o.m_TrafficDescriptorListIsSet = true;
  }
  if (j.find("reportUeReachable") != j.end()) {
    j.at("reportUeReachable").get_to(o.m_ReportUeReachable);
    o.m_ReportUeReachableIsSet = true;
  }
  if (j.find("reachabilityFilter") != j.end()) {
    j.at("reachabilityFilter").get_to(o.m_ReachabilityFilter);
    o.m_ReachabilityFilterIsSet = true;
  }
  if (j.find("udmDetectInd") != j.end()) {
    j.at("udmDetectInd").get_to(o.m_UdmDetectInd);
    o.m_UdmDetectIndIsSet = true;
  }
  if (j.find("maxReports") != j.end()) {
    j.at("maxReports").get_to(o.m_MaxReports);
    o.m_MaxReportsIsSet = true;
  }
  if (j.find("presenceInfoList") != j.end()) {
    j.at("presenceInfoList").get_to(o.m_PresenceInfoList);
    o.m_PresenceInfoListIsSet = true;
  }
  if (j.find("maxResponseTime") != j.end()) {
    j.at("maxResponseTime").get_to(o.m_MaxResponseTime);
    o.m_MaxResponseTimeIsSet = true;
  }
  if (j.find("targetArea") != j.end()) {
    j.at("targetArea").get_to(o.m_TargetArea);
    o.m_TargetAreaIsSet = true;
  }
  if (j.find("snssaiFilter") != j.end()) {
    j.at("snssaiFilter").get_to(o.m_SnssaiFilter);
    o.m_SnssaiFilterIsSet = true;
  }
}

AmfEventType AmfEvent::getType() const { return m_Type; }
void AmfEvent::setType(AmfEventType const &value) { m_Type = value; }
bool AmfEvent::isImmediateFlag() const { return m_ImmediateFlag; }
void AmfEvent::setImmediateFlag(bool const value) {
  m_ImmediateFlag = value;
  m_ImmediateFlagIsSet = true;
}
bool AmfEvent::immediateFlagIsSet() const { return m_ImmediateFlagIsSet; }
void AmfEvent::unsetImmediateFlag() { m_ImmediateFlagIsSet = false; }
std::vector<AmfEventArea> &AmfEvent::getAreaList() { return m_AreaList; }
void AmfEvent::setAreaList(std::vector<AmfEventArea> const &value) {
  m_AreaList = value;
  m_AreaListIsSet = true;
}
bool AmfEvent::areaListIsSet() const { return m_AreaListIsSet; }
void AmfEvent::unsetAreaList() { m_AreaListIsSet = false; }
std::vector<LocationFilter> &AmfEvent::getLocationFilterList() {
  return m_LocationFilterList;
}
void AmfEvent::setLocationFilterList(std::vector<LocationFilter> const &value) {
  m_LocationFilterList = value;
  m_LocationFilterListIsSet = true;
}
bool AmfEvent::locationFilterListIsSet() const {
  return m_LocationFilterListIsSet;
}
void AmfEvent::unsetLocationFilterList() { m_LocationFilterListIsSet = false; }
int32_t AmfEvent::getRefId() const { return m_RefId; }
void AmfEvent::setRefId(int32_t const value) {
  m_RefId = value;
  m_RefIdIsSet = true;
}
bool AmfEvent::refIdIsSet() const { return m_RefIdIsSet; }
void AmfEvent::unsetRefId() { m_RefIdIsSet = false; }
std::vector<TrafficDescriptor> &AmfEvent::getTrafficDescriptorList() {
  return m_TrafficDescriptorList;
}
void AmfEvent::setTrafficDescriptorList(
    std::vector<TrafficDescriptor> const &value) {
  m_TrafficDescriptorList = value;
  m_TrafficDescriptorListIsSet = true;
}
bool AmfEvent::trafficDescriptorListIsSet() const {
  return m_TrafficDescriptorListIsSet;
}
void AmfEvent::unsetTrafficDescriptorList() {
  m_TrafficDescriptorListIsSet = false;
}
bool AmfEvent::isReportUeReachable() const { return m_ReportUeReachable; }
void AmfEvent::setReportUeReachable(bool const value) {
  m_ReportUeReachable = value;
  m_ReportUeReachableIsSet = true;
}
bool AmfEvent::reportUeReachableIsSet() const {
  return m_ReportUeReachableIsSet;
}
void AmfEvent::unsetReportUeReachable() { m_ReportUeReachableIsSet = false; }
ReachabilityFilter AmfEvent::getReachabilityFilter() const {
  return m_ReachabilityFilter;
}
void AmfEvent::setReachabilityFilter(ReachabilityFilter const &value) {
  m_ReachabilityFilter = value;
  m_ReachabilityFilterIsSet = true;
}
bool AmfEvent::reachabilityFilterIsSet() const {
  return m_ReachabilityFilterIsSet;
}
void AmfEvent::unsetReachabilityFilter() { m_ReachabilityFilterIsSet = false; }
bool AmfEvent::isUdmDetectInd() const { return m_UdmDetectInd; }
void AmfEvent::setUdmDetectInd(bool const value) {
  m_UdmDetectInd = value;
  m_UdmDetectIndIsSet = true;
}
bool AmfEvent::udmDetectIndIsSet() const { return m_UdmDetectIndIsSet; }
void AmfEvent::unsetUdmDetectInd() { m_UdmDetectIndIsSet = false; }
int32_t AmfEvent::getMaxReports() const { return m_MaxReports; }
void AmfEvent::setMaxReports(int32_t const value) {
  m_MaxReports = value;
  m_MaxReportsIsSet = true;
}
bool AmfEvent::maxReportsIsSet() const { return m_MaxReportsIsSet; }
void AmfEvent::unsetMaxReports() { m_MaxReportsIsSet = false; }
std::map<std::string, PresenceInfo> &AmfEvent::getPresenceInfoList() {
  return m_PresenceInfoList;
}
void AmfEvent::setPresenceInfoList(
    std::map<std::string, PresenceInfo> const &value) {
  m_PresenceInfoList = value;
  m_PresenceInfoListIsSet = true;
}
bool AmfEvent::presenceInfoListIsSet() const { return m_PresenceInfoListIsSet; }
void AmfEvent::unsetPresenceInfoList() { m_PresenceInfoListIsSet = false; }
int32_t AmfEvent::getMaxResponseTime() const { return m_MaxResponseTime; }
void AmfEvent::setMaxResponseTime(int32_t const value) {
  m_MaxResponseTime = value;
  m_MaxResponseTimeIsSet = true;
}
bool AmfEvent::maxResponseTimeIsSet() const { return m_MaxResponseTimeIsSet; }
void AmfEvent::unsetMaxResponseTime() { m_MaxResponseTimeIsSet = false; }
TargetArea AmfEvent::getTargetArea() const { return m_TargetArea; }
void AmfEvent::setTargetArea(TargetArea const &value) {
  m_TargetArea = value;
  m_TargetAreaIsSet = true;
}
bool AmfEvent::targetAreaIsSet() const { return m_TargetAreaIsSet; }
void AmfEvent::unsetTargetArea() { m_TargetAreaIsSet = false; }
std::vector<ExtSnssai> &AmfEvent::getSnssaiFilter() { return m_SnssaiFilter; }
void AmfEvent::setSnssaiFilter(std::vector<ExtSnssai> const &value) {
  m_SnssaiFilter = value;
  m_SnssaiFilterIsSet = true;
}
bool AmfEvent::snssaiFilterIsSet() const { return m_SnssaiFilterIsSet; }
void AmfEvent::unsetSnssaiFilter() { m_SnssaiFilterIsSet = false; }

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
