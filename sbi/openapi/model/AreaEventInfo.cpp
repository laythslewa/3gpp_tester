/**
 * LMF Location
 * LMF Location Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA,
 * ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "AreaEventInfo.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

AreaEventInfo::AreaEventInfo() {
  m_OccurrenceInfoIsSet = false;
  m_MinimumInterval = 0;
  m_MinimumIntervalIsSet = false;
  m_MaximumInterval = 0;
  m_MaximumIntervalIsSet = false;
  m_SamplingInterval = 0;
  m_SamplingIntervalIsSet = false;
  m_ReportingDuration = 0;
  m_ReportingDurationIsSet = false;
  m_ReportingLocationReq = false;
  m_ReportingLocationReqIsSet = false;
}

AreaEventInfo::~AreaEventInfo() {}

void AreaEventInfo::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const AreaEventInfo &o) {
  j = nlohmann::json();
  j["areaDefinition"] = o.m_AreaDefinition;
  if (o.occurrenceInfoIsSet())
    j["occurrenceInfo"] = o.m_OccurrenceInfo;
  if (o.minimumIntervalIsSet())
    j["minimumInterval"] = o.m_MinimumInterval;
  if (o.maximumIntervalIsSet())
    j["maximumInterval"] = o.m_MaximumInterval;
  if (o.samplingIntervalIsSet())
    j["samplingInterval"] = o.m_SamplingInterval;
  if (o.reportingDurationIsSet())
    j["reportingDuration"] = o.m_ReportingDuration;
  if (o.reportingLocationReqIsSet())
    j["reportingLocationReq"] = o.m_ReportingLocationReq;
}

void from_json(const nlohmann::json &j, AreaEventInfo &o) {
  j.at("areaDefinition").get_to(o.m_AreaDefinition);
  if (j.find("occurrenceInfo") != j.end()) {
    j.at("occurrenceInfo").get_to(o.m_OccurrenceInfo);
    o.m_OccurrenceInfoIsSet = true;
  }
  if (j.find("minimumInterval") != j.end()) {
    j.at("minimumInterval").get_to(o.m_MinimumInterval);
    o.m_MinimumIntervalIsSet = true;
  }
  if (j.find("maximumInterval") != j.end()) {
    j.at("maximumInterval").get_to(o.m_MaximumInterval);
    o.m_MaximumIntervalIsSet = true;
  }
  if (j.find("samplingInterval") != j.end()) {
    j.at("samplingInterval").get_to(o.m_SamplingInterval);
    o.m_SamplingIntervalIsSet = true;
  }
  if (j.find("reportingDuration") != j.end()) {
    j.at("reportingDuration").get_to(o.m_ReportingDuration);
    o.m_ReportingDurationIsSet = true;
  }
  if (j.find("reportingLocationReq") != j.end()) {
    j.at("reportingLocationReq").get_to(o.m_ReportingLocationReq);
    o.m_ReportingLocationReqIsSet = true;
  }
}

std::vector<ReportingArea> &AreaEventInfo::getAreaDefinition() {
  return m_AreaDefinition;
}
void AreaEventInfo::setAreaDefinition(std::vector<ReportingArea> const &value) {
  m_AreaDefinition = value;
}
OccurrenceInfo AreaEventInfo::getOccurrenceInfo() const {
  return m_OccurrenceInfo;
}
void AreaEventInfo::setOccurrenceInfo(OccurrenceInfo const &value) {
  m_OccurrenceInfo = value;
  m_OccurrenceInfoIsSet = true;
}
bool AreaEventInfo::occurrenceInfoIsSet() const {
  return m_OccurrenceInfoIsSet;
}
void AreaEventInfo::unsetOccurrenceInfo() { m_OccurrenceInfoIsSet = false; }
int32_t AreaEventInfo::getMinimumInterval() const { return m_MinimumInterval; }
void AreaEventInfo::setMinimumInterval(int32_t const value) {
  m_MinimumInterval = value;
  m_MinimumIntervalIsSet = true;
}
bool AreaEventInfo::minimumIntervalIsSet() const {
  return m_MinimumIntervalIsSet;
}
void AreaEventInfo::unsetMinimumInterval() { m_MinimumIntervalIsSet = false; }
int32_t AreaEventInfo::getMaximumInterval() const { return m_MaximumInterval; }
void AreaEventInfo::setMaximumInterval(int32_t const value) {
  m_MaximumInterval = value;
  m_MaximumIntervalIsSet = true;
}
bool AreaEventInfo::maximumIntervalIsSet() const {
  return m_MaximumIntervalIsSet;
}
void AreaEventInfo::unsetMaximumInterval() { m_MaximumIntervalIsSet = false; }
int32_t AreaEventInfo::getSamplingInterval() const {
  return m_SamplingInterval;
}
void AreaEventInfo::setSamplingInterval(int32_t const value) {
  m_SamplingInterval = value;
  m_SamplingIntervalIsSet = true;
}
bool AreaEventInfo::samplingIntervalIsSet() const {
  return m_SamplingIntervalIsSet;
}
void AreaEventInfo::unsetSamplingInterval() { m_SamplingIntervalIsSet = false; }
int32_t AreaEventInfo::getReportingDuration() const {
  return m_ReportingDuration;
}
void AreaEventInfo::setReportingDuration(int32_t const value) {
  m_ReportingDuration = value;
  m_ReportingDurationIsSet = true;
}
bool AreaEventInfo::reportingDurationIsSet() const {
  return m_ReportingDurationIsSet;
}
void AreaEventInfo::unsetReportingDuration() {
  m_ReportingDurationIsSet = false;
}
bool AreaEventInfo::isReportingLocationReq() const {
  return m_ReportingLocationReq;
}
void AreaEventInfo::setReportingLocationReq(bool const value) {
  m_ReportingLocationReq = value;
  m_ReportingLocationReqIsSet = true;
}
bool AreaEventInfo::reportingLocationReqIsSet() const {
  return m_ReportingLocationReqIsSet;
}
void AreaEventInfo::unsetReportingLocationReq() {
  m_ReportingLocationReqIsSet = false;
}

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
