/**
 * Nsmf_PDUSession
 * SMF PDU Session Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "HsmfUpdatedData.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

HsmfUpdatedData::HsmfUpdatedData() {
  m_N1SmInfoToUeIsSet = false;
  m_N4InfoIsSet = false;
  m_N4InfoExt1IsSet = false;
  m_N4InfoExt2IsSet = false;
  m_DnaiListIsSet = false;
  m_SupportedFeatures = "";
  m_SupportedFeaturesIsSet = false;
  m_RoamingChargingProfileIsSet = false;
  m_UpSecurityIsSet = false;
  m_MaxIntegrityProtectedDataRateUlIsSet = false;
  m_MaxIntegrityProtectedDataRateDlIsSet = false;
  m_Ipv6MultiHomingInd = false;
  m_Ipv6MultiHomingIndIsSet = false;
  m_QosFlowsSetupListIsSet = false;
  m_SessionAmbrIsSet = false;
  m_EpsPdnCnxInfoIsSet = false;
  m_EpsBearerInfoIsSet = false;
  m_Pti = 0;
  m_PtiIsSet = false;
}

HsmfUpdatedData::~HsmfUpdatedData() {}

void HsmfUpdatedData::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const HsmfUpdatedData &o) {
  j = nlohmann::json();
  if (o.n1SmInfoToUeIsSet())
    j["n1SmInfoToUe"] = o.m_N1SmInfoToUe;
  if (o.n4InfoIsSet())
    j["n4Info"] = o.m_N4Info;
  if (o.n4InfoExt1IsSet())
    j["n4InfoExt1"] = o.m_N4InfoExt1;
  if (o.n4InfoExt2IsSet())
    j["n4InfoExt2"] = o.m_N4InfoExt2;
  if (o.dnaiListIsSet() || !o.m_DnaiList.empty())
    j["dnaiList"] = o.m_DnaiList;
  if (o.supportedFeaturesIsSet())
    j["supportedFeatures"] = o.m_SupportedFeatures;
  if (o.roamingChargingProfileIsSet())
    j["roamingChargingProfile"] = o.m_RoamingChargingProfile;
  if (o.upSecurityIsSet())
    j["upSecurity"] = o.m_UpSecurity;
  if (o.maxIntegrityProtectedDataRateUlIsSet())
    j["maxIntegrityProtectedDataRateUl"] = o.m_MaxIntegrityProtectedDataRateUl;
  if (o.maxIntegrityProtectedDataRateDlIsSet())
    j["maxIntegrityProtectedDataRateDl"] = o.m_MaxIntegrityProtectedDataRateDl;
  if (o.ipv6MultiHomingIndIsSet())
    j["ipv6MultiHomingInd"] = o.m_Ipv6MultiHomingInd;
  if (o.qosFlowsSetupListIsSet() || !o.m_QosFlowsSetupList.empty())
    j["qosFlowsSetupList"] = o.m_QosFlowsSetupList;
  if (o.sessionAmbrIsSet())
    j["sessionAmbr"] = o.m_SessionAmbr;
  if (o.epsPdnCnxInfoIsSet())
    j["epsPdnCnxInfo"] = o.m_EpsPdnCnxInfo;
  if (o.epsBearerInfoIsSet() || !o.m_EpsBearerInfo.empty())
    j["epsBearerInfo"] = o.m_EpsBearerInfo;
  if (o.ptiIsSet())
    j["pti"] = o.m_Pti;
}

void from_json(const nlohmann::json &j, HsmfUpdatedData &o) {
  if (j.find("n1SmInfoToUe") != j.end()) {
    j.at("n1SmInfoToUe").get_to(o.m_N1SmInfoToUe);
    o.m_N1SmInfoToUeIsSet = true;
  }
  if (j.find("n4Info") != j.end()) {
    j.at("n4Info").get_to(o.m_N4Info);
    o.m_N4InfoIsSet = true;
  }
  if (j.find("n4InfoExt1") != j.end()) {
    j.at("n4InfoExt1").get_to(o.m_N4InfoExt1);
    o.m_N4InfoExt1IsSet = true;
  }
  if (j.find("n4InfoExt2") != j.end()) {
    j.at("n4InfoExt2").get_to(o.m_N4InfoExt2);
    o.m_N4InfoExt2IsSet = true;
  }
  if (j.find("dnaiList") != j.end()) {
    j.at("dnaiList").get_to(o.m_DnaiList);
    o.m_DnaiListIsSet = true;
  }
  if (j.find("supportedFeatures") != j.end()) {
    j.at("supportedFeatures").get_to(o.m_SupportedFeatures);
    o.m_SupportedFeaturesIsSet = true;
  }
  if (j.find("roamingChargingProfile") != j.end()) {
    j.at("roamingChargingProfile").get_to(o.m_RoamingChargingProfile);
    o.m_RoamingChargingProfileIsSet = true;
  }
  if (j.find("upSecurity") != j.end()) {
    j.at("upSecurity").get_to(o.m_UpSecurity);
    o.m_UpSecurityIsSet = true;
  }
  if (j.find("maxIntegrityProtectedDataRateUl") != j.end()) {
    j.at("maxIntegrityProtectedDataRateUl")
        .get_to(o.m_MaxIntegrityProtectedDataRateUl);
    o.m_MaxIntegrityProtectedDataRateUlIsSet = true;
  }
  if (j.find("maxIntegrityProtectedDataRateDl") != j.end()) {
    j.at("maxIntegrityProtectedDataRateDl")
        .get_to(o.m_MaxIntegrityProtectedDataRateDl);
    o.m_MaxIntegrityProtectedDataRateDlIsSet = true;
  }
  if (j.find("ipv6MultiHomingInd") != j.end()) {
    j.at("ipv6MultiHomingInd").get_to(o.m_Ipv6MultiHomingInd);
    o.m_Ipv6MultiHomingIndIsSet = true;
  }
  if (j.find("qosFlowsSetupList") != j.end()) {
    j.at("qosFlowsSetupList").get_to(o.m_QosFlowsSetupList);
    o.m_QosFlowsSetupListIsSet = true;
  }
  if (j.find("sessionAmbr") != j.end()) {
    j.at("sessionAmbr").get_to(o.m_SessionAmbr);
    o.m_SessionAmbrIsSet = true;
  }
  if (j.find("epsPdnCnxInfo") != j.end()) {
    j.at("epsPdnCnxInfo").get_to(o.m_EpsPdnCnxInfo);
    o.m_EpsPdnCnxInfoIsSet = true;
  }
  if (j.find("epsBearerInfo") != j.end()) {
    j.at("epsBearerInfo").get_to(o.m_EpsBearerInfo);
    o.m_EpsBearerInfoIsSet = true;
  }
  if (j.find("pti") != j.end()) {
    j.at("pti").get_to(o.m_Pti);
    o.m_PtiIsSet = true;
  }
}

RefToBinaryData HsmfUpdatedData::getN1SmInfoToUe() const {
  return m_N1SmInfoToUe;
}
void HsmfUpdatedData::setN1SmInfoToUe(RefToBinaryData const &value) {
  m_N1SmInfoToUe = value;
  m_N1SmInfoToUeIsSet = true;
}
bool HsmfUpdatedData::n1SmInfoToUeIsSet() const { return m_N1SmInfoToUeIsSet; }
void HsmfUpdatedData::unsetN1SmInfoToUe() { m_N1SmInfoToUeIsSet = false; }
N4Information HsmfUpdatedData::getN4Info() const { return m_N4Info; }
void HsmfUpdatedData::setN4Info(N4Information const &value) {
  m_N4Info = value;
  m_N4InfoIsSet = true;
}
bool HsmfUpdatedData::n4InfoIsSet() const { return m_N4InfoIsSet; }
void HsmfUpdatedData::unsetN4Info() { m_N4InfoIsSet = false; }
N4Information HsmfUpdatedData::getN4InfoExt1() const { return m_N4InfoExt1; }
void HsmfUpdatedData::setN4InfoExt1(N4Information const &value) {
  m_N4InfoExt1 = value;
  m_N4InfoExt1IsSet = true;
}
bool HsmfUpdatedData::n4InfoExt1IsSet() const { return m_N4InfoExt1IsSet; }
void HsmfUpdatedData::unsetN4InfoExt1() { m_N4InfoExt1IsSet = false; }
N4Information HsmfUpdatedData::getN4InfoExt2() const { return m_N4InfoExt2; }
void HsmfUpdatedData::setN4InfoExt2(N4Information const &value) {
  m_N4InfoExt2 = value;
  m_N4InfoExt2IsSet = true;
}
bool HsmfUpdatedData::n4InfoExt2IsSet() const { return m_N4InfoExt2IsSet; }
void HsmfUpdatedData::unsetN4InfoExt2() { m_N4InfoExt2IsSet = false; }
std::vector<std::string> &HsmfUpdatedData::getDnaiList() { return m_DnaiList; }
void HsmfUpdatedData::setDnaiList(std::vector<std::string> const &value) {
  m_DnaiList = value;
  m_DnaiListIsSet = true;
}
bool HsmfUpdatedData::dnaiListIsSet() const { return m_DnaiListIsSet; }
void HsmfUpdatedData::unsetDnaiList() { m_DnaiListIsSet = false; }
std::string HsmfUpdatedData::getSupportedFeatures() const {
  return m_SupportedFeatures;
}
void HsmfUpdatedData::setSupportedFeatures(std::string const &value) {
  m_SupportedFeatures = value;
  m_SupportedFeaturesIsSet = true;
}
bool HsmfUpdatedData::supportedFeaturesIsSet() const {
  return m_SupportedFeaturesIsSet;
}
void HsmfUpdatedData::unsetSupportedFeatures() {
  m_SupportedFeaturesIsSet = false;
}
RoamingChargingProfile HsmfUpdatedData::getRoamingChargingProfile() const {
  return m_RoamingChargingProfile;
}
void HsmfUpdatedData::setRoamingChargingProfile(
    RoamingChargingProfile const &value) {
  m_RoamingChargingProfile = value;
  m_RoamingChargingProfileIsSet = true;
}
bool HsmfUpdatedData::roamingChargingProfileIsSet() const {
  return m_RoamingChargingProfileIsSet;
}
void HsmfUpdatedData::unsetRoamingChargingProfile() {
  m_RoamingChargingProfileIsSet = false;
}
UpSecurity HsmfUpdatedData::getUpSecurity() const { return m_UpSecurity; }
void HsmfUpdatedData::setUpSecurity(UpSecurity const &value) {
  m_UpSecurity = value;
  m_UpSecurityIsSet = true;
}
bool HsmfUpdatedData::upSecurityIsSet() const { return m_UpSecurityIsSet; }
void HsmfUpdatedData::unsetUpSecurity() { m_UpSecurityIsSet = false; }
MaxIntegrityProtectedDataRate
HsmfUpdatedData::getMaxIntegrityProtectedDataRateUl() const {
  return m_MaxIntegrityProtectedDataRateUl;
}
void HsmfUpdatedData::setMaxIntegrityProtectedDataRateUl(
    MaxIntegrityProtectedDataRate const &value) {
  m_MaxIntegrityProtectedDataRateUl = value;
  m_MaxIntegrityProtectedDataRateUlIsSet = true;
}
bool HsmfUpdatedData::maxIntegrityProtectedDataRateUlIsSet() const {
  return m_MaxIntegrityProtectedDataRateUlIsSet;
}
void HsmfUpdatedData::unsetMaxIntegrityProtectedDataRateUl() {
  m_MaxIntegrityProtectedDataRateUlIsSet = false;
}
MaxIntegrityProtectedDataRate
HsmfUpdatedData::getMaxIntegrityProtectedDataRateDl() const {
  return m_MaxIntegrityProtectedDataRateDl;
}
void HsmfUpdatedData::setMaxIntegrityProtectedDataRateDl(
    MaxIntegrityProtectedDataRate const &value) {
  m_MaxIntegrityProtectedDataRateDl = value;
  m_MaxIntegrityProtectedDataRateDlIsSet = true;
}
bool HsmfUpdatedData::maxIntegrityProtectedDataRateDlIsSet() const {
  return m_MaxIntegrityProtectedDataRateDlIsSet;
}
void HsmfUpdatedData::unsetMaxIntegrityProtectedDataRateDl() {
  m_MaxIntegrityProtectedDataRateDlIsSet = false;
}
bool HsmfUpdatedData::isIpv6MultiHomingInd() const {
  return m_Ipv6MultiHomingInd;
}
void HsmfUpdatedData::setIpv6MultiHomingInd(bool const value) {
  m_Ipv6MultiHomingInd = value;
  m_Ipv6MultiHomingIndIsSet = true;
}
bool HsmfUpdatedData::ipv6MultiHomingIndIsSet() const {
  return m_Ipv6MultiHomingIndIsSet;
}
void HsmfUpdatedData::unsetIpv6MultiHomingInd() {
  m_Ipv6MultiHomingIndIsSet = false;
}
std::vector<QosFlowSetupItem> &HsmfUpdatedData::getQosFlowsSetupList() {
  return m_QosFlowsSetupList;
}
void HsmfUpdatedData::setQosFlowsSetupList(
    std::vector<QosFlowSetupItem> const &value) {
  m_QosFlowsSetupList = value;
  m_QosFlowsSetupListIsSet = true;
}
bool HsmfUpdatedData::qosFlowsSetupListIsSet() const {
  return m_QosFlowsSetupListIsSet;
}
void HsmfUpdatedData::unsetQosFlowsSetupList() {
  m_QosFlowsSetupListIsSet = false;
}
Ambr HsmfUpdatedData::getSessionAmbr() const { return m_SessionAmbr; }
void HsmfUpdatedData::setSessionAmbr(Ambr const &value) {
  m_SessionAmbr = value;
  m_SessionAmbrIsSet = true;
}
bool HsmfUpdatedData::sessionAmbrIsSet() const { return m_SessionAmbrIsSet; }
void HsmfUpdatedData::unsetSessionAmbr() { m_SessionAmbrIsSet = false; }
EpsPdnCnxInfo HsmfUpdatedData::getEpsPdnCnxInfo() const {
  return m_EpsPdnCnxInfo;
}
void HsmfUpdatedData::setEpsPdnCnxInfo(EpsPdnCnxInfo const &value) {
  m_EpsPdnCnxInfo = value;
  m_EpsPdnCnxInfoIsSet = true;
}
bool HsmfUpdatedData::epsPdnCnxInfoIsSet() const {
  return m_EpsPdnCnxInfoIsSet;
}
void HsmfUpdatedData::unsetEpsPdnCnxInfo() { m_EpsPdnCnxInfoIsSet = false; }
std::vector<EpsBearerInfo> &HsmfUpdatedData::getEpsBearerInfo() {
  return m_EpsBearerInfo;
}
void HsmfUpdatedData::setEpsBearerInfo(
    std::vector<EpsBearerInfo> const &value) {
  m_EpsBearerInfo = value;
  m_EpsBearerInfoIsSet = true;
}
bool HsmfUpdatedData::epsBearerInfoIsSet() const {
  return m_EpsBearerInfoIsSet;
}
void HsmfUpdatedData::unsetEpsBearerInfo() { m_EpsBearerInfoIsSet = false; }
int32_t HsmfUpdatedData::getPti() const { return m_Pti; }
void HsmfUpdatedData::setPti(int32_t const value) {
  m_Pti = value;
  m_PtiIsSet = true;
}
bool HsmfUpdatedData::ptiIsSet() const { return m_PtiIsSet; }
void HsmfUpdatedData::unsetPti() { m_PtiIsSet = false; }

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
