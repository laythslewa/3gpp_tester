/**
 * NRF NFManagement Service
 * NRF NFManagement Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "ScpDomainInfo.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

ScpDomainInfo::ScpDomainInfo() {
  m_ScpFqdn = "";
  m_ScpFqdnIsSet = false;
  m_ScpIpEndPointsIsSet = false;
  m_ScpPrefix = "";
  m_ScpPrefixIsSet = false;
  m_ScpPortsIsSet = false;
}

ScpDomainInfo::~ScpDomainInfo() {}

void ScpDomainInfo::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const ScpDomainInfo &o) {
  j = nlohmann::json();
  if (o.scpFqdnIsSet())
    j["scpFqdn"] = o.m_ScpFqdn;
  if (o.scpIpEndPointsIsSet() || !o.m_ScpIpEndPoints.empty())
    j["scpIpEndPoints"] = o.m_ScpIpEndPoints;
  if (o.scpPrefixIsSet())
    j["scpPrefix"] = o.m_ScpPrefix;
  if (o.scpPortsIsSet() || !o.m_ScpPorts.empty())
    j["scpPorts"] = o.m_ScpPorts;
}

void from_json(const nlohmann::json &j, ScpDomainInfo &o) {
  if (j.find("scpFqdn") != j.end()) {
    j.at("scpFqdn").get_to(o.m_ScpFqdn);
    o.m_ScpFqdnIsSet = true;
  }
  if (j.find("scpIpEndPoints") != j.end()) {
    j.at("scpIpEndPoints").get_to(o.m_ScpIpEndPoints);
    o.m_ScpIpEndPointsIsSet = true;
  }
  if (j.find("scpPrefix") != j.end()) {
    j.at("scpPrefix").get_to(o.m_ScpPrefix);
    o.m_ScpPrefixIsSet = true;
  }
  if (j.find("scpPorts") != j.end()) {
    j.at("scpPorts").get_to(o.m_ScpPorts);
    o.m_ScpPortsIsSet = true;
  }
}

std::string ScpDomainInfo::getScpFqdn() const { return m_ScpFqdn; }
void ScpDomainInfo::setScpFqdn(std::string const &value) {
  m_ScpFqdn = value;
  m_ScpFqdnIsSet = true;
}
bool ScpDomainInfo::scpFqdnIsSet() const { return m_ScpFqdnIsSet; }
void ScpDomainInfo::unsetScpFqdn() { m_ScpFqdnIsSet = false; }
std::vector<IpEndPoint> &ScpDomainInfo::getScpIpEndPoints() {
  return m_ScpIpEndPoints;
}
void ScpDomainInfo::setScpIpEndPoints(std::vector<IpEndPoint> const &value) {
  m_ScpIpEndPoints = value;
  m_ScpIpEndPointsIsSet = true;
}
bool ScpDomainInfo::scpIpEndPointsIsSet() const {
  return m_ScpIpEndPointsIsSet;
}
void ScpDomainInfo::unsetScpIpEndPoints() { m_ScpIpEndPointsIsSet = false; }
std::string ScpDomainInfo::getScpPrefix() const { return m_ScpPrefix; }
void ScpDomainInfo::setScpPrefix(std::string const &value) {
  m_ScpPrefix = value;
  m_ScpPrefixIsSet = true;
}
bool ScpDomainInfo::scpPrefixIsSet() const { return m_ScpPrefixIsSet; }
void ScpDomainInfo::unsetScpPrefix() { m_ScpPrefixIsSet = false; }
std::map<std::string, int32_t> &ScpDomainInfo::getScpPorts() {
  return m_ScpPorts;
}
void ScpDomainInfo::setScpPorts(std::map<std::string, int32_t> const value) {
  m_ScpPorts = value;
  m_ScpPortsIsSet = true;
}
bool ScpDomainInfo::scpPortsIsSet() const { return m_ScpPortsIsSet; }
void ScpDomainInfo::unsetScpPorts() { m_ScpPortsIsSet = false; }

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
