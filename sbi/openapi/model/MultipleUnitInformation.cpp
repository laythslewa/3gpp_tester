/**
 * Nchf_ConvergedCharging
 * ConvergedCharging Service    Â© 2020, 3GPP Organizational Partners (ARIB,
 * ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 3.0.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "MultipleUnitInformation.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

MultipleUnitInformation::MultipleUnitInformation() {
  m_ResultCodeIsSet = false;
  m_RatingGroup = 0;
  m_GrantedUnitIsSet = false;
  m_TriggersIsSet = false;
  m_ValidityTime = 0;
  m_ValidityTimeIsSet = false;
  m_QuotaHoldingTime = 0;
  m_QuotaHoldingTimeIsSet = false;
  m_FinalUnitIndicationIsSet = false;
  m_TimeQuotaThreshold = 0;
  m_TimeQuotaThresholdIsSet = false;
  m_VolumeQuotaThreshold = 0;
  m_VolumeQuotaThresholdIsSet = false;
  m_UnitQuotaThreshold = 0;
  m_UnitQuotaThresholdIsSet = false;
  m_UPFID = "";
  m_UPFIDIsSet = false;
}

MultipleUnitInformation::~MultipleUnitInformation() {}

void MultipleUnitInformation::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const MultipleUnitInformation &o) {
  j = nlohmann::json();
  if (o.resultCodeIsSet())
    j["resultCode"] = o.m_ResultCode;
  j["ratingGroup"] = o.m_RatingGroup;
  if (o.grantedUnitIsSet())
    j["grantedUnit"] = o.m_GrantedUnit;
  if (o.triggersIsSet() || !o.m_Triggers.empty())
    j["triggers"] = o.m_Triggers;
  if (o.validityTimeIsSet())
    j["validityTime"] = o.m_ValidityTime;
  if (o.quotaHoldingTimeIsSet())
    j["quotaHoldingTime"] = o.m_QuotaHoldingTime;
  if (o.finalUnitIndicationIsSet())
    j["finalUnitIndication"] = o.m_FinalUnitIndication;
  if (o.timeQuotaThresholdIsSet())
    j["timeQuotaThreshold"] = o.m_TimeQuotaThreshold;
  if (o.volumeQuotaThresholdIsSet())
    j["volumeQuotaThreshold"] = o.m_VolumeQuotaThreshold;
  if (o.unitQuotaThresholdIsSet())
    j["unitQuotaThreshold"] = o.m_UnitQuotaThreshold;
  if (o.uPFIDIsSet())
    j["uPFID"] = o.m_UPFID;
}

void from_json(const nlohmann::json &j, MultipleUnitInformation &o) {
  if (j.find("resultCode") != j.end()) {
    j.at("resultCode").get_to(o.m_ResultCode);
    o.m_ResultCodeIsSet = true;
  }
  j.at("ratingGroup").get_to(o.m_RatingGroup);
  if (j.find("grantedUnit") != j.end()) {
    j.at("grantedUnit").get_to(o.m_GrantedUnit);
    o.m_GrantedUnitIsSet = true;
  }
  if (j.find("triggers") != j.end()) {
    j.at("triggers").get_to(o.m_Triggers);
    o.m_TriggersIsSet = true;
  }
  if (j.find("validityTime") != j.end()) {
    j.at("validityTime").get_to(o.m_ValidityTime);
    o.m_ValidityTimeIsSet = true;
  }
  if (j.find("quotaHoldingTime") != j.end()) {
    j.at("quotaHoldingTime").get_to(o.m_QuotaHoldingTime);
    o.m_QuotaHoldingTimeIsSet = true;
  }
  if (j.find("finalUnitIndication") != j.end()) {
    j.at("finalUnitIndication").get_to(o.m_FinalUnitIndication);
    o.m_FinalUnitIndicationIsSet = true;
  }
  if (j.find("timeQuotaThreshold") != j.end()) {
    j.at("timeQuotaThreshold").get_to(o.m_TimeQuotaThreshold);
    o.m_TimeQuotaThresholdIsSet = true;
  }
  if (j.find("volumeQuotaThreshold") != j.end()) {
    j.at("volumeQuotaThreshold").get_to(o.m_VolumeQuotaThreshold);
    o.m_VolumeQuotaThresholdIsSet = true;
  }
  if (j.find("unitQuotaThreshold") != j.end()) {
    j.at("unitQuotaThreshold").get_to(o.m_UnitQuotaThreshold);
    o.m_UnitQuotaThresholdIsSet = true;
  }
  if (j.find("uPFID") != j.end()) {
    j.at("uPFID").get_to(o.m_UPFID);
    o.m_UPFIDIsSet = true;
  }
}

ResultCode MultipleUnitInformation::getResultCode() const {
  return m_ResultCode;
}
void MultipleUnitInformation::setResultCode(ResultCode const &value) {
  m_ResultCode = value;
  m_ResultCodeIsSet = true;
}
bool MultipleUnitInformation::resultCodeIsSet() const {
  return m_ResultCodeIsSet;
}
void MultipleUnitInformation::unsetResultCode() { m_ResultCodeIsSet = false; }
int32_t MultipleUnitInformation::getRatingGroup() const {
  return m_RatingGroup;
}
void MultipleUnitInformation::setRatingGroup(int32_t const value) {
  m_RatingGroup = value;
}
GrantedUnit MultipleUnitInformation::getGrantedUnit() const {
  return m_GrantedUnit;
}
void MultipleUnitInformation::setGrantedUnit(GrantedUnit const &value) {
  m_GrantedUnit = value;
  m_GrantedUnitIsSet = true;
}
bool MultipleUnitInformation::grantedUnitIsSet() const {
  return m_GrantedUnitIsSet;
}
void MultipleUnitInformation::unsetGrantedUnit() { m_GrantedUnitIsSet = false; }
std::vector<Trigger> &MultipleUnitInformation::getTriggers() {
  return m_Triggers;
}
void MultipleUnitInformation::setTriggers(std::vector<Trigger> const &value) {
  m_Triggers = value;
  m_TriggersIsSet = true;
}
bool MultipleUnitInformation::triggersIsSet() const { return m_TriggersIsSet; }
void MultipleUnitInformation::unsetTriggers() { m_TriggersIsSet = false; }
int32_t MultipleUnitInformation::getValidityTime() const {
  return m_ValidityTime;
}
void MultipleUnitInformation::setValidityTime(int32_t const value) {
  m_ValidityTime = value;
  m_ValidityTimeIsSet = true;
}
bool MultipleUnitInformation::validityTimeIsSet() const {
  return m_ValidityTimeIsSet;
}
void MultipleUnitInformation::unsetValidityTime() {
  m_ValidityTimeIsSet = false;
}
int32_t MultipleUnitInformation::getQuotaHoldingTime() const {
  return m_QuotaHoldingTime;
}
void MultipleUnitInformation::setQuotaHoldingTime(int32_t const value) {
  m_QuotaHoldingTime = value;
  m_QuotaHoldingTimeIsSet = true;
}
bool MultipleUnitInformation::quotaHoldingTimeIsSet() const {
  return m_QuotaHoldingTimeIsSet;
}
void MultipleUnitInformation::unsetQuotaHoldingTime() {
  m_QuotaHoldingTimeIsSet = false;
}
FinalUnitIndication MultipleUnitInformation::getFinalUnitIndication() const {
  return m_FinalUnitIndication;
}
void MultipleUnitInformation::setFinalUnitIndication(
    FinalUnitIndication const &value) {
  m_FinalUnitIndication = value;
  m_FinalUnitIndicationIsSet = true;
}
bool MultipleUnitInformation::finalUnitIndicationIsSet() const {
  return m_FinalUnitIndicationIsSet;
}
void MultipleUnitInformation::unsetFinalUnitIndication() {
  m_FinalUnitIndicationIsSet = false;
}
int32_t MultipleUnitInformation::getTimeQuotaThreshold() const {
  return m_TimeQuotaThreshold;
}
void MultipleUnitInformation::setTimeQuotaThreshold(int32_t const value) {
  m_TimeQuotaThreshold = value;
  m_TimeQuotaThresholdIsSet = true;
}
bool MultipleUnitInformation::timeQuotaThresholdIsSet() const {
  return m_TimeQuotaThresholdIsSet;
}
void MultipleUnitInformation::unsetTimeQuotaThreshold() {
  m_TimeQuotaThresholdIsSet = false;
}
int32_t MultipleUnitInformation::getVolumeQuotaThreshold() const {
  return m_VolumeQuotaThreshold;
}
void MultipleUnitInformation::setVolumeQuotaThreshold(int32_t const value) {
  m_VolumeQuotaThreshold = value;
  m_VolumeQuotaThresholdIsSet = true;
}
bool MultipleUnitInformation::volumeQuotaThresholdIsSet() const {
  return m_VolumeQuotaThresholdIsSet;
}
void MultipleUnitInformation::unsetVolumeQuotaThreshold() {
  m_VolumeQuotaThresholdIsSet = false;
}
int32_t MultipleUnitInformation::getUnitQuotaThreshold() const {
  return m_UnitQuotaThreshold;
}
void MultipleUnitInformation::setUnitQuotaThreshold(int32_t const value) {
  m_UnitQuotaThreshold = value;
  m_UnitQuotaThresholdIsSet = true;
}
bool MultipleUnitInformation::unitQuotaThresholdIsSet() const {
  return m_UnitQuotaThresholdIsSet;
}
void MultipleUnitInformation::unsetUnitQuotaThreshold() {
  m_UnitQuotaThresholdIsSet = false;
}
std::string MultipleUnitInformation::getUPFID() const { return m_UPFID; }
void MultipleUnitInformation::setUPFID(std::string const &value) {
  m_UPFID = value;
  m_UPFIDIsSet = true;
}
bool MultipleUnitInformation::uPFIDIsSet() const { return m_UPFIDIsSet; }
void MultipleUnitInformation::unsetUPFID() { m_UPFIDIsSet = false; }

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
