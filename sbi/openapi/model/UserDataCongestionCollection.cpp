/**
 * Nnef_EventExposure
 * NEF Event Exposure Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0-alpha.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "UserDataCongestionCollection.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

UserDataCongestionCollection::UserDataCongestionCollection() {
  m_AppId = "";
  m_AppIdIsSet = false;
  m_IpTrafficFilterIsSet = false;
  m_TimeIntervIsSet = false;
  m_ThrputUl = "";
  m_ThrputUlIsSet = false;
  m_ThrputDl = "";
  m_ThrputDlIsSet = false;
  m_ThrputPkUl = "";
  m_ThrputPkUlIsSet = false;
  m_ThrputPkDl = "";
  m_ThrputPkDlIsSet = false;
}

UserDataCongestionCollection::~UserDataCongestionCollection() {}

void UserDataCongestionCollection::validate() {
  // TODO: implement validation
}

void to_json(nlohmann::json &j, const UserDataCongestionCollection &o) {
  j = nlohmann::json();
  if (o.appIdIsSet())
    j["appId"] = o.m_AppId;
  if (o.ipTrafficFilterIsSet())
    j["ipTrafficFilter"] = o.m_IpTrafficFilter;
  if (o.timeIntervIsSet())
    j["timeInterv"] = o.m_TimeInterv;
  if (o.thrputUlIsSet())
    j["thrputUl"] = o.m_ThrputUl;
  if (o.thrputDlIsSet())
    j["thrputDl"] = o.m_ThrputDl;
  if (o.thrputPkUlIsSet())
    j["thrputPkUl"] = o.m_ThrputPkUl;
  if (o.thrputPkDlIsSet())
    j["thrputPkDl"] = o.m_ThrputPkDl;
}

void from_json(const nlohmann::json &j, UserDataCongestionCollection &o) {
  if (j.find("appId") != j.end()) {
    j.at("appId").get_to(o.m_AppId);
    o.m_AppIdIsSet = true;
  }
  if (j.find("ipTrafficFilter") != j.end()) {
    j.at("ipTrafficFilter").get_to(o.m_IpTrafficFilter);
    o.m_IpTrafficFilterIsSet = true;
  }
  if (j.find("timeInterv") != j.end()) {
    j.at("timeInterv").get_to(o.m_TimeInterv);
    o.m_TimeIntervIsSet = true;
  }
  if (j.find("thrputUl") != j.end()) {
    j.at("thrputUl").get_to(o.m_ThrputUl);
    o.m_ThrputUlIsSet = true;
  }
  if (j.find("thrputDl") != j.end()) {
    j.at("thrputDl").get_to(o.m_ThrputDl);
    o.m_ThrputDlIsSet = true;
  }
  if (j.find("thrputPkUl") != j.end()) {
    j.at("thrputPkUl").get_to(o.m_ThrputPkUl);
    o.m_ThrputPkUlIsSet = true;
  }
  if (j.find("thrputPkDl") != j.end()) {
    j.at("thrputPkDl").get_to(o.m_ThrputPkDl);
    o.m_ThrputPkDlIsSet = true;
  }
}

std::string UserDataCongestionCollection::getAppId() const { return m_AppId; }
void UserDataCongestionCollection::setAppId(std::string const &value) {
  m_AppId = value;
  m_AppIdIsSet = true;
}
bool UserDataCongestionCollection::appIdIsSet() const { return m_AppIdIsSet; }
void UserDataCongestionCollection::unsetAppId() { m_AppIdIsSet = false; }
FlowInfo UserDataCongestionCollection::getIpTrafficFilter() const {
  return m_IpTrafficFilter;
}
void UserDataCongestionCollection::setIpTrafficFilter(FlowInfo const &value) {
  m_IpTrafficFilter = value;
  m_IpTrafficFilterIsSet = true;
}
bool UserDataCongestionCollection::ipTrafficFilterIsSet() const {
  return m_IpTrafficFilterIsSet;
}
void UserDataCongestionCollection::unsetIpTrafficFilter() {
  m_IpTrafficFilterIsSet = false;
}
TimeWindow UserDataCongestionCollection::getTimeInterv() const {
  return m_TimeInterv;
}
void UserDataCongestionCollection::setTimeInterv(TimeWindow const &value) {
  m_TimeInterv = value;
  m_TimeIntervIsSet = true;
}
bool UserDataCongestionCollection::timeIntervIsSet() const {
  return m_TimeIntervIsSet;
}
void UserDataCongestionCollection::unsetTimeInterv() {
  m_TimeIntervIsSet = false;
}
std::string UserDataCongestionCollection::getThrputUl() const {
  return m_ThrputUl;
}
void UserDataCongestionCollection::setThrputUl(std::string const &value) {
  m_ThrputUl = value;
  m_ThrputUlIsSet = true;
}
bool UserDataCongestionCollection::thrputUlIsSet() const {
  return m_ThrputUlIsSet;
}
void UserDataCongestionCollection::unsetThrputUl() { m_ThrputUlIsSet = false; }
std::string UserDataCongestionCollection::getThrputDl() const {
  return m_ThrputDl;
}
void UserDataCongestionCollection::setThrputDl(std::string const &value) {
  m_ThrputDl = value;
  m_ThrputDlIsSet = true;
}
bool UserDataCongestionCollection::thrputDlIsSet() const {
  return m_ThrputDlIsSet;
}
void UserDataCongestionCollection::unsetThrputDl() { m_ThrputDlIsSet = false; }
std::string UserDataCongestionCollection::getThrputPkUl() const {
  return m_ThrputPkUl;
}
void UserDataCongestionCollection::setThrputPkUl(std::string const &value) {
  m_ThrputPkUl = value;
  m_ThrputPkUlIsSet = true;
}
bool UserDataCongestionCollection::thrputPkUlIsSet() const {
  return m_ThrputPkUlIsSet;
}
void UserDataCongestionCollection::unsetThrputPkUl() {
  m_ThrputPkUlIsSet = false;
}
std::string UserDataCongestionCollection::getThrputPkDl() const {
  return m_ThrputPkDl;
}
void UserDataCongestionCollection::setThrputPkDl(std::string const &value) {
  m_ThrputPkDl = value;
  m_ThrputPkDlIsSet = true;
}
bool UserDataCongestionCollection::thrputPkDlIsSet() const {
  return m_ThrputPkDlIsSet;
}
void UserDataCongestionCollection::unsetThrputPkDl() {
  m_ThrputPkDlIsSet = false;
}

} // namespace model
} // namespace server
} // namespace openapitools
} // namespace org
